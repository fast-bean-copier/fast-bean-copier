# Fast Bean Copier 需求文档

## 文档信息

| 项目名称 | Fast Bean Copier                        |
|---------|-----------------------------------------|
| 项目坐标 | com.github.jackieonway                  |
| 项目名称 | fast-bean-copier                        |
| 包名 | com.github.jackieonway.copier           |
| 版本号 | 1.0.0                                   |
| 文档版本 | v1.0                                    |
| 编写日期 | 2025                                    |
| 技术方案 | 纯APT（Annotation Processing Tool）编译期代码生成 |
| Java版本 | 最低支持 Java 8                             |

## 一、项目概述

### 1.1 项目背景

在Java开发中，经常需要在不同的对象之间进行数据拷贝，例如：
- 实体类（Entity）与DTO之间的转换
- 实体类与VO之间的转换
- 领域对象与数据传输对象之间的转换

目前常用的拷贝方案存在以下问题：
- **反射方案**（如BeanUtils）：性能较差，运行时开销大
- **MapStruct**：性能优秀但使用不够简洁，需要定义Mapper接口
- **手动编写**：代码量大，维护成本高

### 1.2 项目目标

开发一个高性能、易用的Bean拷贝工具，要求：

1. **性能目标**：性能与手工编写代码完全一致，超过或达到MapStruct的性能
2. **易用性目标**：使用比MapStruct更简洁，减少50%以上的代码量，零配置使用
3. **功能目标**：支持同名字段拷贝、嵌套对象深拷贝、集合拷贝等核心功能
4. **技术目标**：纯APT技术实现，零运行时依赖，零运行时开销

### 1.3 核心价值

- ✅ **零运行时开销**：编译期生成纯Java代码，运行时性能与手写代码一致
- ✅ **使用极简**：无需定义Mapper接口，一行代码完成拷贝
- ✅ **零配置使用**：无需手动配置APT处理器路径，引入依赖即用
- ✅ **类型安全**：编译期完整类型检查，编译时发现错误
- ✅ **深拷贝支持**：所有拷贝都是深拷贝，包括嵌套对象

## 二、技术选型

### 2.1 核心技术

1. **代码生成工具**：JavaPoet
2. **构建工具**：Maven
3. **Java版本**：最低支持 Java 8
4. **APT自动注册**：Google Auto Service

### 2.2 项目结构

```
fast-bean-copier/
├── fast-bean-copier-annotations/     # 注解定义模块
│   ├── src/main/java/
│   │   └── com/github/jackieonway/copier/annotation/
│   │       └── CopyTarget.java
│   └── pom.xml
│
├── fast-bean-copier-processor/       # APT处理器模块
│   ├── src/main/java/
│   │   └── com/github/jackieonway/copier/processor/
│   │       ├── BeanCopierProcessor.java
│   │       ├── FieldMapping.java
│   │       ├── CodeGenerator.java
│   │       └── TypeUtils.java
│   └── pom.xml
│
└── fast-bean-copier-examples/        # 示例项目（可选）
    ├── src/main/java/
    └── pom.xml
```

## 三、功能需求

### 3.1 基础功能需求

#### 3.1.1 同名字段自动拷贝

**功能描述**：支持源对象和目标对象之间的同名字段自动映射

**详细需求**：

1. **同名字段自动映射**
   - 源类和目标类中同名同类型字段自动映射
   - 支持基本类型、包装类型、String等常用类型
   - 示例：`User.name -> UserDto.name`

2. **类型兼容性规则**
   - **完全匹配**：`String -> String`, `Long -> Long` 等，直接拷贝
   - **基本类型 ↔ 包装类型**：自动转换
     - `int ↔ Integer`
     - `long ↔ Long`
     - `short ↔ Short`
     - `byte ↔ Byte`
     - `float ↔ Float`
     - `double ↔ Double`
     - `char ↔ Character`
     - `boolean ↔ Boolean`
   - **类型不匹配**：编译期报错，提示字段名和类型信息
     - 示例：`String -> Integer` 会报错

3. **类型转换代码生成**
   - 基本类型 -> 包装类型：自动装箱
     ```java
     // 源：int age
     // 目标：Integer age
     target.setAge(Integer.valueOf(source.getAge()));
     ```
   - 包装类型 -> 基本类型：自动拆箱，需要处理null
     ```java
     // 源：Integer age
     // 目标：int age
     Integer ageValue = source.getAge();
     target.setAge(ageValue != null ? ageValue.intValue() : 0);
     ```

**验收标准**：
- [ ] 同名字段能够正确拷贝
- [ ] 基本类型与包装类型能够自动转换
- [ ] 类型不匹配时能够正确报错
- [ ] null值处理正确

#### 3.1.2 字段忽略功能

**功能描述**：支持忽略不需要拷贝的字段

**详细需求**：

1. **忽略字段配置**
   - 通过`@CopyTarget.ignore`属性指定要忽略的字段列表
   - 忽略的字段在正向和反向拷贝中都不处理
   - 忽略字段名区分大小写

2. **忽略字段处理**
   - 如果忽略的字段不存在，编译期给出警告（不报错）
   - 忽略字段不参与类型检查
   - 忽略字段不生成任何拷贝代码

**使用示例**：

```java
@CopyTarget(source = User.class, ignore = {"password", "secretKey"})
public class UserDto {
    private Long id;
    private String name;
    // password 和 secretKey 字段不会被拷贝
}
```

**生成的代码**：

```java
public static UserDto toDto(User source) {
    if (source == null) return null;
    UserDto target = new UserDto();
    target.setId(source.getId());
    target.setName(source.getName());
    // password 和 secretKey 字段被忽略，不生成代码
    return target;
}
```

**验收标准**：
- [ ] 忽略的字段不会被拷贝
- [ ] 正向和反向拷贝都忽略指定字段
- [ ] 字段不存在时给出警告

#### 3.1.3 嵌套对象深拷贝

**功能描述**：支持嵌套对象的递归深拷贝，所有拷贝都必须是深拷贝

**详细需求**：

1. **有注解的嵌套对象（深拷贝）**
   - 嵌套对象有`@CopyTarget`注解时，调用对应的Copier进行递归拷贝
   - 类型可以不同，通过Copier转换
   - 示例：`User.address -> UserDto.addressDto`（Address有@CopyTarget注解）

2. **无注解的嵌套对象（深拷贝）**
   - 嵌套对象没有`@CopyTarget`注解时，必须进行深拷贝
   - 递归调用所有字段的getter/setter方法
   - 类型必须完全匹配
   - 必须存在对应的getter和setter方法
   - 示例：`User.address -> UserDto.address`（Address无注解，类型匹配）

3. **嵌套对象类型匹配规则**
   - 有注解：类型可以不同，通过Copier转换
   - 无注解：类型必须完全匹配，递归拷贝所有字段

4. **多级嵌套支持**
   - 支持多级嵌套对象的递归深拷贝
   - 自动处理嵌套层次关系
   - 每层嵌套对象都会递归处理

5. **null安全检查**
   - 嵌套对象为null时，目标对象相应字段也为null
   - 不会抛出NullPointerException
   - 生成代码中包含null检查

6. **循环依赖检测**
   - 编译期检测循环依赖情况（仅针对有注解的嵌套对象）
   - 提供友好的错误提示
   - 防止无限递归

**使用示例**：

```java
// 示例1：有注解的嵌套对象
@CopyTarget(source = Address.class)
public class AddressDto {
    private String street;
    private String city;
}

public class User {
    private Long id;
    private Address address;  // 有注解的嵌套对象
}

@CopyTarget(source = User.class)
public class UserDto {
    private Long id;
    private AddressDto address;  // 调用AddressDtoCopier.toDto()
}
```

**生成的代码（有注解）**：

```java
public static UserDto toDto(User source) {
    if (source == null) return null;
    UserDto target = new UserDto();
    target.setId(source.getId());
    // address 有注解，调用Copier（深拷贝）
    if (source.getAddress() != null) {
        target.setAddress(AddressDtoCopier.toDto(source.getAddress()));
    }
    return target;
}
```

```java
// 示例2：无注解的嵌套对象
public class Address {  // 无注解
    private String street;
    private String city;
}

public class User {
    private Long id;
    private Address address;  // 无注解嵌套对象
}

@CopyTarget(source = User.class)
public class UserDto {
    private Long id;
    private Address address;  // 类型匹配，深拷贝所有字段
}
```

**生成的代码（无注解）**：

```java
public static UserDto toDto(User source) {
    if (source == null) return null;
    UserDto target = new UserDto();
    target.setId(source.getId());
    // address 无注解，类型匹配，递归深拷贝所有字段
    if (source.getAddress() != null) {
        Address address = new Address();
        address.setStreet(source.getAddress().getStreet());
        address.setCity(source.getAddress().getCity());
        target.setAddress(address);
    }
    return target;
}
```

**验收标准**：
- [ ] 有注解的嵌套对象能够正确调用Copier进行深拷贝
- [ ] 无注解的嵌套对象能够递归深拷贝所有字段
- [ ] 多级嵌套对象能够正确递归深拷贝
- [ ] null值不会导致空指针异常
- [ ] 循环依赖能够被检测并报错（仅针对有注解的嵌套对象）
- [ ] 无注解嵌套对象类型不匹配时能够报错

#### 3.1.4 集合拷贝（优化方案）

**功能描述**：支持集合类型的数据拷贝，采用最优的集合拷贝方案

**详细需求**：

1. **List拷贝（优化）**
   - 支持`List<Source>`到`List<Target>`的拷贝
   - 自动生成`toDtoList()`方法
   - **优化方案**：预分配容量 + 传统for循环（性能最优）
   - 保持List的顺序和大小
   - 集合中的嵌套对象也会递归深拷贝

2. **Set拷贝（优化）**
   - 支持`Set<Source>`到`Set<Target>`的拷贝
   - 自动生成`toDtoSet()`方法
   - **优化方案**：预分配容量 + 传统for循环（性能最优）
   - 保持Set的特性（去重）
   - 集合中的嵌套对象也会递归深拷贝

3. **null和空集合处理**
   - null集合拷贝结果为null
   - 空集合拷贝结果为空集合（预分配容量为0）
   - 使用合适的初始容量优化性能

4. **集合元素类型转换**
   - 自动识别集合元素类型
   - 如果元素是嵌套对象，自动递归深拷贝
   - 如果元素是基本类型，直接拷贝

**生成的代码（List优化方案）**：

```java
public static List<UserDto> toDtoList(List<User> sources) {
    if (sources == null) return null;
    if (sources.isEmpty()) return new ArrayList<>();
    List<UserDto> targets = new ArrayList<>(sources.size());
    for (User source : sources) {
        targets.add(toDto(source));
    }
    return targets;
}
```

**生成的代码（Set优化方案）**：

```java
public static Set<UserDto> toDtoSet(Set<User> sources) {
    if (sources == null) return null;
    if (sources.isEmpty()) return new LinkedHashSet<>();
    Set<UserDto> targets = new LinkedHashSet<>(sources.size());
    for (User source : sources) {
        targets.add(toDto(source));
    }
    return targets;
}
```

**优化说明**：
- 使用预分配容量的集合，避免扩容开销
- 使用传统for循环，性能最优（比forEach和Stream API稍快）
- 空集合特殊处理，直接返回空集合
- 保持集合特性（List顺序、Set去重）

**验收标准**：
- [ ] List能够正确拷贝并保持顺序
- [ ] Set能够正确拷贝并保持去重特性
- [ ] null集合和空集合能够正确处理
- [ ] 集合中的嵌套对象能够正确递归深拷贝
- [ ] 集合拷贝性能达到最优

### 3.2 高级功能需求

#### 3.2.1 反向拷贝

**功能描述**：支持目标对象到源对象的反向拷贝

**详细需求**：

1. **fromDto方法生成**
   - 自动生成`fromDto()`方法
   - 实现`Target -> Source`的拷贝
   - 映射规则与`toDto()`相反

2. **字段映射一致性**
   - 反向拷贝的字段映射与正向拷贝保持一致
   - 忽略字段在反向拷贝中同样被忽略
   - 类型转换在反向拷贝中正确反转

3. **嵌套对象反向处理**
   - 有注解的嵌套对象：调用对应的Copier.fromDto()
   - 无注解的嵌套对象：递归深拷贝所有字段（反向）

4. **类型转换反向处理**
   - 基本类型 ↔ 包装类型的转换在反向拷贝中正确反转
   - null值处理正确

**生成的代码示例**：

```java
public static User fromDto(UserDto source) {
    if (source == null) return null;
    User target = new User();
    target.setId(source.getId());
    target.setName(source.getName());
    // 嵌套对象反向拷贝
    if (source.getAddress() != null) {
        target.setAddress(AddressDtoCopier.fromDto(source.getAddress()));
    }
    return target;
}
```

**验收标准**：
- [ ] fromDto方法能够正确生成
- [ ] 反向拷贝能够正确工作
- [ ] 字段映射在反向拷贝中保持一致
- [ ] 嵌套对象反向处理正确
- [ ] 类型转换反向处理正确

#### 3.2.2 集合反向拷贝

**功能描述**：支持集合类型的反向拷贝

**详细需求**：

1. **列表反向拷贝（优化）**
   - 自动生成`fromDtoList()`方法
   - 实现`List<Target> -> List<Source>`的拷贝
   - 采用最优的集合拷贝方案

2. **集合反向拷贝（优化）**
   - 自动生成`fromDtoSet()`方法
   - 实现`Set<Target> -> Set<Source>`的拷贝
   - 采用最优的集合拷贝方案

**生成的代码（列表反向拷贝）**：

```java
public static List<User> fromDtoList(List<UserDto> sources) {
    if (sources == null) return null;
    if (sources.isEmpty()) return new ArrayList<>();
    List<User> targets = new ArrayList<>(sources.size());
    for (UserDto source : sources) {
        targets.add(fromDto(source));
    }
    return targets;
}
```

**生成的代码（集合反向拷贝）**：

```java
public static Set<User> fromDtoSet(Set<UserDto> sources) {
    if (sources == null) return null;
    if (sources.isEmpty()) return new LinkedHashSet<>();
    Set<User> targets = new LinkedHashSet<>(sources.size());
    for (UserDto source : sources) {
        targets.add(fromDto(source));
    }
    return targets;
}
```

**验收标准**：
- [ ] 列表反向拷贝能够正确工作
- [ ] 集合反向拷贝能够正确工作
- [ ] 集合中的嵌套对象能够正确递归深拷贝

### 3.3 编译期功能需求

#### 3.3.1 类型安全检查

**功能描述**：编译期进行完整的类型检查

**详细需求**：

1. **类存在性检查**
   - 检查源类和目标类是否存在
   - 检查类是否可访问
   - 提供清晰的错误提示

2. **字段类型兼容性检查**
   - 检查源字段和目标字段类型是否兼容
   - 检查是否可以转换
   - 对不兼容的类型给出错误提示

3. **嵌套对象类型检查**
   - 检查嵌套对象类型是否匹配
   - 有注解：检查是否存在对应的Copier
   - 无注解：检查类型是否完全匹配，是否存在getter/setter

4. **方法存在性检查**
   - 检查getter/setter方法是否存在
   - 检查方法签名是否正确
   - 提供友好的错误提示

5. **字段忽略检查**
   - 检查忽略的字段是否存在
   - 字段不存在时给出警告（不报错）

6. **循环依赖检测**
   - 编译期检测循环依赖情况（仅针对有注解的嵌套对象）
   - 提供友好的错误提示
   - 防止无限递归

**验收标准**：
- [ ] 不存在的类能够被检测并报错
- [ ] 类型不兼容能够被检测并报错
- [ ] 缺少getter/setter方法能够被检测并报错
- [ ] 循环依赖能够被检测并报错
- [ ] 错误提示清晰友好

#### 3.3.2 代码生成

**功能描述**：编译期生成高效的工具类代码

**详细需求**：

1. **代码生成位置**
   - 生成到`target/generated-sources/annotations`目录
   - 包名与目标类相同
   - 类名规则：`{TargetClassName}Copier`

2. **代码质量**
   - 生成的代码格式规范
   - 包含必要的注释
   - 代码风格一致

3. **代码优化**
   - 减少不必要的null检查
   - 优化集合初始化（预分配容量）
   - 避免重复的类型判断
   - 使用最优的集合拷贝方案

4. **错误处理**
   - 生成代码时如果出错，提供清晰的错误信息
   - 不影响其他类的正常处理

5. **嵌套对象代码生成**
   - 有注解：生成调用Copier的代码
   - 无注解：生成递归深拷贝所有字段的代码
   - 优化嵌套调用的代码结构

**验收标准**：
- [ ] 代码生成到正确的位置
- [ ] 生成的代码格式规范，可读性好
- [ ] 生成的代码经过优化，性能良好
- [ ] 代码生成错误能够被正确处理
- [ ] 嵌套对象代码正确生成

## 四、接口设计

### 4.1 注解接口

#### 4.1.1 @CopyTarget

```java
package com.github.jackieonway.copier.annotation;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface CopyTarget {
    /**
     * 源类
     */
    Class<?> source();
    
    /**
     * 忽略的字段列表（字段名）
     */
    String[] ignore() default {};
}
```

### 4.2 生成的Copier接口

#### 4.2.1 基本方法

每个生成的Copier类包含以下方法：

```java
public final class UserDtoCopier {
    private UserDtoCopier() {}
    
    /**
     * 拷贝 User -> UserDto
     */
    public static UserDto toDto(User source);
    
    /**
     * 反向拷贝 UserDto -> User
     */
    public static User fromDto(UserDto source);
    
    /**
     * 列表拷贝
     */
    public static List<UserDto> toDtoList(List<User> sources);
    
    /**
     * 集合拷贝
     */
    public static Set<UserDto> toDtoSet(Set<User> sources);
    
    /**
     * 列表反向拷贝
     */
    public static List<User> fromDtoList(List<UserDto> sources);
    
    /**
     * 集合反向拷贝
     */
    public static Set<User> fromDtoSet(Set<UserDto> sources);
}
```

## 五、使用示例

### 5.1 基础使用

```java
// 1. 定义实体类
public class User {
    private Long id;
    private String name;
    private String email;
    private int age;  // 基本类型
    // getter/setter...
}

// 2. 定义DTO类并添加注解
@CopyTarget(source = User.class, ignore = {"password"})
public class UserDto {
    private Long id;
    private String name;
    private String email;
    private Integer age;  // int -> Integer 自动转换
    // password 字段被忽略
    // getter/setter...
}

// 3. 编译后自动生成UserDtoCopier，直接使用
User user = new User();
user.setId(1L);
user.setName("张三");
user.setEmail("zhangsan@example.com");
user.setAge(25);

// 正向拷贝
UserDto dto = UserDtoCopier.toDto(user);

// 反向拷贝
User user2 = UserDtoCopier.fromDto(dto);

// 列表拷贝
List<User> users = Arrays.asList(user);
List<UserDto> dtos = UserDtoCopier.toDtoList(users);

// 集合拷贝
Set<User> userSet = new HashSet<>(users);
Set<UserDto> dtoSet = UserDtoCopier.toDtoSet(userSet);
```

### 5.2 嵌套对象使用

```java
// 示例1：有注解的嵌套对象
@CopyTarget(source = Address.class)
public class AddressDto {
    private String street;
    private String city;
}

public class Address {
    private String street;
    private String city;
}

public class User {
    private Long id;
    private Address address;  // 有注解的嵌套对象
}

@CopyTarget(source = User.class)
public class UserDto {
    private Long id;
    private AddressDto address;  // 调用AddressDtoCopier.toDto()
}

// 使用
User user = new User();
user.setAddress(new Address("中关村", "北京"));
UserDto dto = UserDtoCopier.toDto(user);  // address会调用AddressDtoCopier

// 示例2：无注解的嵌套对象
public class Address {  // 无注解
    private String street;
    private String city;
}

public class User {
    private Long id;
    private Address address;  // 无注解嵌套对象
}

@CopyTarget(source = User.class)
public class UserDto {
    private Long id;
    private Address address;  // 类型匹配，递归深拷贝所有字段
}

// 使用
User user = new User();
user.setAddress(new Address("中关村", "北京"));
UserDto dto = UserDtoCopier.toDto(user);  // address会递归深拷贝所有字段
```

## 六、非功能需求

### 6.1 性能需求

1. **编译期性能**
   - 注解处理器执行时间：单个类 < 100ms
   - 大型项目（100+类）整体处理时间 < 10s
   - 不影响正常编译速度

2. **运行时性能**
   - 单个对象拷贝：< 1μs（微秒）
   - 1000个对象拷贝：< 1ms
   - 嵌套对象拷贝（深度3层）：< 2ms
   - 列表拷贝（1000项）：< 5ms
   - 性能与手写代码相当，超过或达到MapStruct的性能

3. **内存使用**
   - 编译期内存使用合理，不影响正常编译
   - 运行时零额外内存开销（无运行时依赖）

### 6.2 兼容性需求

1. **Java版本**
   - 最低支持Java 8
   - 支持Java 8、Java 9等版本
   - 使用Java 8的API和特性

2. **构建工具**
   - 支持Maven 3.6+
   - 支持Gradle 6.0+
   - 支持IDE（IntelliJ IDEA、Eclipse等）

3. **框架集成**
   - 支持Spring Boot项目
   - 支持其他Java框架
   - 无框架依赖，可独立使用

### 6.3 可维护性需求

1. **代码质量**
   - 代码结构清晰，模块划分合理
   - 注释完整，文档齐全
   - 遵循Java编码规范

2. **可扩展性**
   - 易于添加新的类型转换支持
   - 易于扩展匹配规则
   - 易于添加新的功能特性

3. **可测试性**
   - 单元测试覆盖率 > 80%
   - 集成测试覆盖主要功能
   - 性能基准测试

### 6.4 易用性需求

1. **学习成本**
   - API设计直观，易于理解
   - 文档清晰，示例丰富
   - 上手时间 < 10分钟

2. **开发体验**
   - IDE智能提示支持
   - 编译期错误提示友好
   - 生成的代码可查看和调试

3. **配置灵活性**
   - 支持零配置使用（自动推断）
   - 支持注解配置
   - 支持灵活的字段映射

## 七、验收标准

### 7.1 功能验收

- [ ] **基本功能**
  - [ ] 同名字段能够正确拷贝
  - [ ] 基本类型与包装类型能够自动转换
  - [ ] 类型不匹配时能够正确报错
  - [ ] 字段忽略功能正常

- [ ] **嵌套对象**
  - [ ] 有注解的嵌套对象能够正确调用Copier进行深拷贝
  - [ ] 无注解的嵌套对象能够递归深拷贝所有字段
  - [ ] 多级嵌套对象能够正确递归深拷贝
  - [ ] null值不会导致空指针异常
  - [ ] 循环依赖能够被检测并报错（仅针对有注解的嵌套对象）

- [ ] **集合处理**
  - [ ] List能够正确拷贝并保持顺序
  - [ ] Set能够正确拷贝并保持去重特性
  - [ ] null集合和空集合能够正确处理
  - [ ] 集合中的嵌套对象能够正确递归深拷贝
  - [ ] 集合拷贝性能达到最优

- [ ] **反向拷贝**
  - [ ] fromDto方法能够正确生成
  - [ ] 反向拷贝能够正确工作
  - [ ] 嵌套对象反向处理正确
  - [ ] 类型转换反向处理正确
  - [ ] 集合反向拷贝能够正确工作

### 7.2 性能验收

- [ ] **编译期性能**
  - [ ] 单个类处理时间 < 100ms
  - [ ] 100+类项目处理时间 < 10s

- [ ] **运行时性能**
  - [ ] 单个对象拷贝 < 1μs
  - [ ] 1000个对象拷贝 < 1ms
  - [ ] 嵌套对象拷贝（深度3层）< 2ms
  - [ ] 列表拷贝（1000项）< 5ms
  - [ ] 性能测试报告达到预期指标

### 7.3 质量验收

- [ ] **代码质量**
  - [ ] 代码规范检查通过
  - [ ] 单元测试覆盖率 > 80%
  - [ ] 集成测试通过
  - [ ] 无严重bug

- [ ] **文档质量**
  - [ ] README文档完整
  - [ ] API文档完整
  - [ ] 示例代码完整
  - [ ] 使用指南清晰

- [ ] **兼容性**
  - [ ] Java 8+兼容
  - [ ] Maven 3.6+兼容
  - [ ] Gradle 6.0+兼容
  - [ ] IDE兼容

## 八、功能边界（不实现）

以下功能不在当前版本实现：

1. **自定义字段映射**：不支持源字段名和目标字段名不同的映射
2. **复杂类型转换**：不支持 Date -> String 等需要格式化的情况
3. **自定义转换器**：不需要 Converter 接口
4. **一对多/多对一映射**：不支持复杂字段映射
5. **RPC调用**：不支持远程调用转换
6. **默认值**：不支持默认值设置
7. **自动推断**：不支持类名/包名自动匹配（必须使用 @CopyTarget 注解）

## 九、技术实现要点

### 9.1 嵌套对象深拷贝实现

#### 9.1.1 有注解的嵌套对象

```java
// 检测嵌套对象是否有@CopyTarget注解
if (hasCopyTargetAnnotation(nestedType)) {
    // 生成调用Copier的代码
    generateCopierCall(nestedField);
}
```

#### 9.1.2 无注解的嵌套对象

```java
// 检测嵌套对象类型是否完全匹配
if (isTypeCompatible(sourceType, targetType)) {
    // 递归获取所有字段
    List<Field> nestedFields = getAllFields(nestedType);
    // 为每个字段生成getter/setter调用
    for (Field field : nestedFields) {
        generateFieldCopy(field);
    }
}
```

### 9.2 集合拷贝优化实现

```java
// 最优方案：预分配容量 + 传统for循环
MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("toDtoList")
    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
    .returns(ParameterizedTypeName.get(List.class, targetType))
    .addParameter(ParameterizedTypeName.get(List.class, sourceType), "sources")
    .addStatement("if (sources == null) return null")
    .addStatement("if (sources.isEmpty()) return new $T<>()", ArrayList.class)
    .addStatement("$T<$T> targets = new $T<>($L)", 
        List.class, targetType, ArrayList.class, "sources.size()")
    .beginControlFlow("for ($T source : sources)", sourceType)
    .addStatement("targets.add(toDto(source))")
    .endControlFlow()
    .addStatement("return targets");
```

### 9.3 类型转换实现

```java
// 基本类型 -> 包装类型
if (isPrimitive(sourceType) && isWrapper(targetType)) {
    // 生成自动装箱代码
    generateBoxingCode(sourceField, targetField);
}
// 包装类型 -> 基本类型
else if (isWrapper(sourceType) && isPrimitive(targetType)) {
    // 生成自动拆箱代码（需要null检查）
    generateUnboxingCode(sourceField, targetField);
}
```

## 十、附录

### 10.1 术语表

- **APT**：Annotation Processing Tool，Java注解处理工具
- **DTO**：Data Transfer Object，数据传输对象
- **VO**：Value Object，值对象
- **Copier**：拷贝器，生成的工具类
- **深拷贝**：递归拷贝所有字段，创建新对象
- **浅拷贝**：只拷贝引用，不创建新对象（本项目不支持）

### 10.2 参考资料

- Java Annotation Processing Tool (APT) 官方文档
- MapStruct 源码和文档
- Google Auto Service 文档
- JavaPoet 文档

---

**文档结束**

